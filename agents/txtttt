# 1. UPDATE the ConversationContext dataclass in agent_router.py

@dataclass
class ConversationContext:
“”“Enhanced conversation context with query-response history”””
client_id: int
session_start: datetime
last_interaction: datetime
message_count: int
recent_topics: List[str]
last_agent_used: Optional[str]
conversation_summary: str
key_insights: List[str]
# NEW: Add conversation history
conversation_history: List[Dict[str, Any]]  # Store query-response pairs
last_user_query: Optional[str]  # Store most recent query
last_agent_response: Optional[str]  # Store most recent response

# 2. UPDATE the _context_manager_node to initialize new fields

def _context_manager_node(self, state: MultiAgentState) -> MultiAgentState:
“”“Enhanced conversation context and memory management with better follow-up handling”””

```
try:
    print("🧠 [DEBUG] Managing conversation context...")

    # ... existing validation code ...

    client_id = state["client_id"]
    session_id = state.get("session_id", f"session_{client_id}_{datetime.now().strftime('%Y%m%d')}")
    
    # Get or create conversation context
    if session_id in self.contexts:
        context = self.contexts[session_id]
        context.last_interaction = datetime.now()
        context.message_count += 1
        # Store the current query
        context.last_user_query = user_query
        print(f"[DEBUG] 📝 Continuing conversation: message #{context.message_count}")
    else:
        context = ConversationContext(
            client_id=client_id,
            session_start=datetime.now(),
            last_interaction=datetime.now(),
            message_count=1,
            recent_topics=[],
            last_agent_used=None,
            conversation_summary="New conversation started",
            key_insights=[],
            conversation_history=[],  # NEW: Initialize empty history
            last_user_query=user_query,  # NEW: Store current query
            last_agent_response=None  # NEW: Will be set after response
        )
        self.contexts[session_id] = context
        print(f"[DEBUG] 🆕 New conversation started")

    # ... rest of existing topic detection code ...

    state["conversation_context"] = context
    state["session_id"] = session_id
    state["execution_path"].append("context_manager")

    print(f"[DEBUG] Context: {context.message_count} messages, topics: {context.recent_topics}, last agent: {context.last_agent_used or 'None'}")

except Exception as e:
    print(f"❌ Context management error: {e}")
    state["error"] = f"Context management failed: {e}"

return state
```

# 3. UPDATE the _memory_updater_node to store query-response pairs

def _memory_updater_node(self, state: MultiAgentState) -> MultiAgentState:
“”“Update conversation memory and context with query-response history”””

```
try:
    print("💾 [DEBUG] Updating conversation memory...")

    context = state.get("conversation_context")
    if context:
        # Store the current interaction
        current_interaction = {
            "timestamp": datetime.now().isoformat(),
            "user_query": context.last_user_query,
            "agent_response": state.get("final_response"),
            "agent_used": state.get("routing_decision", {}).get("primary_agent"),
            "analysis_type": state.get("routing_decision", {}).get("analysis_type"),
            "success": state.get("error") is None
        }
        
        # Add to conversation history
        context.conversation_history.append(current_interaction)
        
        # Store the response for potential follow-up queries
        context.last_agent_response = state.get("final_response")
        
        # Keep only last 10 interactions to prevent memory bloat
        context.conversation_history = context.conversation_history[-10:]
        
        # Update conversation summary based on recent interactions
        if len(context.conversation_history) >= 2:
            recent_queries = [h["user_query"] for h in context.conversation_history[-3:]]
            context.conversation_summary = f"Recent topics: {', '.join(context.recent_topics)}. Last queries: {'; '.join(recent_queries[-2:])}"
        
        # Extract key insights from the response
        if state.get("final_response"):
            response = state["final_response"]
            if "$" in response and any(word in response.lower() for word in ["spent", "budget", "total"]):
                # Extract monetary insights
                import re
                amounts = re.findall(r'\$[\d,]+(?:\.\d{2})?', response)
                if amounts:
                    insight = f"Recent discussion: {amounts[0]} mentioned"
                    if insight not in context.key_insights:
                        context.key_insights.append(insight)

        # Keep only recent insights
        context.key_insights = context.key_insights[-5:]

        print(f"[DEBUG] 💾 Stored interaction: {context.last_user_query[:50]}... -> {len(state.get('final_response', ''))} chars")
        print(f"[DEBUG] 📚 Total conversation history: {len(context.conversation_history)} interactions")

    state["execution_path"].append("memory_updater")
    print("✅ Memory updated with query-response history")

except Exception as e:
    print(f"❌ Memory update error: {e}")

return state
```

# 4. ADD a method to retrieve conversation history

def get_conversation_history(self, session_id: str, limit: int = 5) -> List[Dict[str, Any]]:
“”“Get recent conversation history for a session”””

```
if session_id in self.contexts:
    context = self.contexts[session_id]
    return context.conversation_history[-limit:] if context.conversation_history else []
else:
    return []
```

# 5. ENHANCE the _context_manager_node to use conversation history for better follow-ups

def _enhanced_followup_detection(self, user_query: str, context: ConversationContext) -> Optional[str]:
“”“Use conversation history to enhance follow-up queries”””

```
if not context.conversation_history:
    return None

query_lower = user_query.lower()
last_interaction = context.conversation_history[-1] if context.conversation_history else None

# Check for follow-up patterns
followup_patterns = ["show me", "tell me more", "what about", "how about", "and", "also"]

if any(pattern in query_lower for pattern in followup_patterns) and last_interaction:
    last_query = last_interaction.get("user_query", "").lower()
    last_response = last_interaction.get("agent_response", "").lower()
    
    # If last query was about spending and this is a follow-up
    if "spend" in last_query and any(word in query_lower for word in ["show", "tell", "more"]):
        return f"Show me more details about my spending patterns (follow-up to: {last_interaction['user_query']})"
    
    # If last response mentioned categories and user wants to see them
    if "categories" in last_response and any(word in query_lower for word in ["show", "categories"]):
        return f"Show me my spending breakdown by categories (follow-up to previous conversation)"

return None
```

# 6. UPDATE get_conversation_summary to include recent interactions

def get_conversation_summary(self, session_id: str) -> Dict[str, Any]:
“”“Get comprehensive conversation summary for a session”””

```
if session_id in self.contexts:
    context = self.contexts[session_id]
    
    # Get recent query-response pairs
    recent_interactions = []
    for interaction in context.conversation_history[-3:]:  # Last 3 interactions
        recent_interactions.append({
            "query": interaction.get("user_query"),
            "response_preview": interaction.get("agent_response", "")[:100] + "..." if interaction.get("agent_response") else "",
            "agent": interaction.get("agent_used"),
            "timestamp": interaction.get("timestamp")
        })
    
    return {
        "session_id": session_id,
        "client_id": context.client_id,
        "session_start": context.session_start.isoformat(),
        "message_count": context.message_count,
        "recent_topics": context.recent_topics,
        "last_agent_used": context.last_agent_used,
        "key_insights": context.key_insights,
        "conversation_summary": context.conversation_summary,
        "recent_interactions": recent_interactions,
        "total_interactions": len(context.conversation_history)
    }
else:
    return {"error": "Session not found"}
```
